{
  "version": 3,
  "sources": ["../../src.ts/bin/the-router.ts", "../../src.ts/base.ts", "../../src.ts/utils.ts", "../../src.ts/index.ts"],
  "sourcesContent": ["#!/usr/bin/env node\n/* eslint-disable no-console */\n\nimport path from \"path\";\nimport { getRouter, resetRouter } from \"../index\";\n\nexport const parseArgs = (args: string[]) => {\n  const options: Record<string, string> = {};\n\n  args.slice(2).forEach((arg) => {\n    if (arg.includes(\"=\")) {\n      const [key, value] = arg.split(\"=\");\n      options[key] = value;\n    }\n  });\n\n  return options;\n};\n\nexport const sync = async (options: Record<string, string>) => {\n  try {\n    if (!options.routesFile) {\n      throw new Error(\"routesFile parameter is required\");\n    }\n\n    resetRouter();\n\n    const routesFilePath = path.resolve(process.cwd(), options.routesFile);\n    console.log(\"Loading routes from:\", routesFilePath);\n\n    await import(routesFilePath);\n\n    const router = getRouter();\n\n    console.log(\"\\nConfigured Routes:\");\n    router.stack.forEach((layer) => {\n      if (layer.route) {\n        const methods = Object.keys(layer.route.methods)\n          .join(\", \")\n          .toUpperCase();\n        console.log(`${methods} ${layer.route.path}`);\n      }\n    });\n  } catch (error) {\n    console.error(\"Error:\", error instanceof Error ? error.message : error);\n    process.exit(1);\n  }\n};\n\n// \u041F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C, \u0437\u0430\u043F\u0443\u0449\u0435\u043D \u043B\u0438 \u0444\u0430\u0439\u043B \u043D\u0430\u043F\u0440\u044F\u043C\u0443\u044E\nconst isMainModule = import.meta.url.startsWith(\"file:\");\n\nif (isMainModule) {\n  const command = process.argv[2];\n  const options = parseArgs(process.argv);\n\n  if (!command) {\n    console.error(\"Error: Command is required. Available commands: sync\");\n    process.exit(1);\n  }\n\n  if (command === \"sync\") {\n    sync(options).catch((error) => {\n      console.error(\"Error:\", error);\n      process.exit(1);\n    });\n  } else {\n    console.error(\"Unknown command. Available commands: sync\");\n    process.exit(1);\n  }\n}\n", "import { Router, RequestHandler, RouterOptions } from \"express\";\n\nconst DEFAULT_ACTIONS_PATH = \"src/actions\";\n\nlet router: Router | null = null;\nlet currentScope: string | null = null;\nlet scopeMiddlewares: RequestHandler[] = [];\nlet actionsPath: string = DEFAULT_ACTIONS_PATH;\nlet isCustomPath: boolean = false;\nlet routerOptions: RouterOptions = {};\n\nexport const setRouterOptions = (options: RouterOptions) => {\n  routerOptions = options;\n};\n\nexport const getRouter = () => {\n  if (!router) {\n    router = Router(routerOptions);\n  }\n  return router;\n};\n\nexport const resetRouter = () => {\n  router = null;\n  currentScope = null;\n  scopeMiddlewares = [];\n  isCustomPath = false;\n  actionsPath = DEFAULT_ACTIONS_PATH;\n  routerOptions = {};\n};\nexport const setActionsPath = (path: string) => {\n  isCustomPath = true;\n  actionsPath = path;\n  return path;\n};\n\nexport const isCustomActionsPath = () => isCustomPath;\nexport const getActionsPath = () => actionsPath;\n\nexport const setRouterScope = (scope: string | null) => {\n  currentScope = scope;\n};\n\nexport const getRouterScope = () => currentScope;\n\nexport const getScopeMiddlewares = () => scopeMiddlewares;\n\nexport const setScopeMiddlewares = (middlewares: RequestHandler[]) => {\n  scopeMiddlewares = middlewares;\n};\n\nexport const routeScope = (\n  scope: string,\n  middlewaresOrCallback: RequestHandler[] | (() => void),\n  routesDefinitionCallback?: () => void\n) => {\n  const scopedRouter = Router(routerOptions);\n  const originalRouter = router;\n  const originalScopeMiddlewares = scopeMiddlewares;\n\n  // Temporarily replace global router with a new one\n  router = scopedRouter;\n\n  // Set current scope and its middlewares\n  setRouterScope(scope);\n\n  if (Array.isArray(middlewaresOrCallback)) {\n    setScopeMiddlewares(middlewaresOrCallback);\n    if (routesDefinitionCallback) {\n      routesDefinitionCallback();\n    }\n  } else {\n    setScopeMiddlewares([]);\n    middlewaresOrCallback();\n  }\n\n  // Restore original router, scope and middlewares\n  router = originalRouter;\n  setRouterScope(null);\n  setScopeMiddlewares(originalScopeMiddlewares);\n\n  // Mount scoped router to the main router with scope prefix\n  getRouter().use(`/${scope}`, scopedRouter);\n};\n", "import fs from \"fs\";\nimport path from \"path\";\nimport { getActionsPath, isCustomActionsPath } from \"./base\";\nimport type { Request, Response } from \"express\";\n\nconst VALID_EXTENSIONS = [\".js\", \".ts\"];\nexport const getProjectRoot = () => process.cwd();\n\nconst validateActionsPath = (actionsPath: string) => {\n  if (!actionsPath) {\n    throw new Error(\"Actions path is not set\");\n  }\n\n  if (!fs.statSync(actionsPath).isDirectory()) {\n    throw new Error(`Actions path ${actionsPath} is not a directory`);\n  }\n};\n\nconst resolveFullActionPath = (\n  actionsPath: string,\n  actionPath: string\n): string => {\n  if (!actionPath) {\n    throw new Error(\"Action path cannot be empty\");\n  }\n\n  const actionFile = `${actionPath}Action`;\n\n  return !isCustomActionsPath()\n    ? path.join(getProjectRoot(), actionsPath, actionFile)\n    : path.join(actionsPath, actionFile);\n};\n\nconst validateActionFile = (\n  fullActionPath: string,\n  validExtensions: string[]\n): string => {\n  for (const ext of validExtensions) {\n    const candidatePath = `${fullActionPath}${ext}`;\n    if (fs.existsSync(candidatePath) && fs.statSync(candidatePath).isFile()) {\n      return candidatePath; // Return the valid file path\n    }\n  }\n  throw new Error(`Action file ${fullActionPath} does not exist`);\n};\n\nconst validateActionModule = (\n  actionModule: { perform?: unknown },\n  fullActionPath: string\n) => {\n  if (typeof actionModule.perform !== \"function\") {\n    throw new Error(\n      `Action module at ${fullActionPath} must export a 'perform' function`\n    );\n  }\n};\n\nexport const loadActionImplementation = (actionPath: string) => {\n  const actionsPath = getActionsPath();\n\n  // Validate actions path\n  validateActionsPath(actionsPath);\n\n  // Resolve full action path without extension\n  const fullActionPath = resolveFullActionPath(actionsPath, actionPath);\n\n  // Validate the file exists with a valid extension\n  const validActionPath = validateActionFile(fullActionPath, VALID_EXTENSIONS);\n\n  // Require the module and validate its structure\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const actionModule = require(validActionPath);\n  validateActionModule(actionModule, validActionPath);\n\n  return actionModule.perform;\n};\n\nexport const loadAction = (actionPath: string) => {\n  try {\n    return loadActionImplementation(actionPath);\n  } catch (error: Error | unknown) {\n    return (req: Request, res: Response) => {\n      res.status(501).json({\n        error: \"Action loading failed\",\n        message: \"Failed to load the specified action\",\n        details: error instanceof Error ? error.message : \"Unknown error\",\n      });\n    };\n  }\n};\n", "import { RequestHandler } from \"express\";\n\nimport {\n  getRouter,\n  getActionsPath,\n  setActionsPath,\n  resetRouter,\n  routeScope,\n  getScopeMiddlewares,\n  setRouterOptions,\n} from \"./base\";\n\nimport { loadAction } from \"./utils\";\n\nexport const root = (\n  middlewares: RequestHandler[] | string,\n  actionPath?: string\n) => {\n  let handlers: RequestHandler[] = [...getScopeMiddlewares()];\n  let finalActionPath: string;\n\n  if (Array.isArray(middlewares)) {\n    if (!actionPath) {\n      throw new Error(\"Action path is required when middlewares are provided\");\n    }\n    handlers = [...handlers, ...middlewares];\n    finalActionPath = actionPath;\n  } else {\n    finalActionPath = middlewares;\n  }\n\n  handlers.push(loadAction(finalActionPath));\n\n  getRouter().get(\"/\", ...handlers);\n};\n\nconst createRouteHandler =\n  (method: string) =>\n  (\n    urlPath: string | RegExp,\n    middlewares: RequestHandler[] | string,\n    actionPath?: string\n  ) => {\n    let handlers: RequestHandler[] = [...getScopeMiddlewares()];\n    let finalActionPath: string;\n\n    if (Array.isArray(middlewares)) {\n      if (!actionPath) {\n        throw new Error(\n          \"Action path is required when middlewares are provided\"\n        );\n      }\n      handlers = [...handlers, ...middlewares];\n      finalActionPath = actionPath;\n    } else {\n      finalActionPath = middlewares;\n    }\n\n    handlers.push(loadAction(finalActionPath));\n\n    const router = getRouter();\n    const path =\n      urlPath instanceof RegExp\n        ? urlPath\n        : urlPath.startsWith(\"/\")\n        ? urlPath\n        : `/${urlPath}`;\n\n    switch (method) {\n      case \"get\":\n        router.get(path, ...handlers);\n        break;\n      case \"post\":\n        router.post(path, ...handlers);\n        break;\n      case \"put\":\n        router.put(path, ...handlers);\n        break;\n      case \"patch\":\n        router.patch(path, ...handlers);\n        break;\n      case \"delete\":\n        router.delete(path, ...handlers);\n        break;\n      case \"options\":\n        router.options(path, ...handlers);\n        break;\n      case \"head\":\n        router.head(path, ...handlers);\n        break;\n      case \"all\":\n        router.all(path, ...handlers);\n        break;\n      default:\n        throw new Error(`Unsupported HTTP method: ${method}`);\n    }\n  };\n\nexport const get = createRouteHandler(\"get\");\nexport const post = createRouteHandler(\"post\");\nexport const put = createRouteHandler(\"put\");\nexport const patch = createRouteHandler(\"patch\");\nexport const destroy = createRouteHandler(\"delete\");\nexport const options = createRouteHandler(\"options\");\nexport const head = createRouteHandler(\"head\");\nexport const all = createRouteHandler(\"all\");\n\ntype ResourceOptions = {\n  only?: string[];\n  except?: string[];\n};\n\nexport const resources = (\n  resourceName: string,\n  middlewaresOrOptions?: RequestHandler[] | ResourceOptions,\n  options?: ResourceOptions\n) => {\n  let middlewares: RequestHandler[] = [];\n  let resourceOptions: ResourceOptions = {};\n\n  // Parse arguments\n  if (Array.isArray(middlewaresOrOptions)) {\n    middlewares = middlewaresOrOptions;\n    resourceOptions = options || {};\n  } else {\n    resourceOptions = middlewaresOrOptions || {};\n  }\n\n  const { only, except } = resourceOptions;\n  const allActions = [\n    \"index\",\n    \"new\",\n    \"create\",\n    \"show\",\n    \"edit\",\n    \"update\",\n    \"destroy\",\n  ];\n\n  // Determine which actions to create\n  let actions = allActions;\n  if (only) {\n    actions = only;\n  } else if (except) {\n    actions = allActions.filter((action) => !except.includes(action));\n  }\n\n  // Normalize resource name and create base path\n  const normalizedName = resourceName.toLowerCase();\n  const basePath = `/${normalizedName}`;\n\n  // Create routes in specific order to ensure proper matching\n  const router = getRouter();\n\n  // 1. Static routes first (no parameters)\n  if (actions.includes(\"new\")) {\n    router.get(\n      basePath + \"/new\",\n      ...createHandlers(middlewares, normalizedName, \"new\")\n    );\n  }\n\n  // 2. Static nested routes\n  if (actions.includes(\"edit\")) {\n    router.get(\n      basePath + \"/:id/edit\",\n      ...createHandlers(middlewares, normalizedName, \"edit\")\n    );\n  }\n\n  // 3. Root level routes (no parameters)\n  if (actions.includes(\"index\")) {\n    router.get(\n      basePath,\n      ...createHandlers(middlewares, normalizedName, \"index\")\n    );\n  }\n  if (actions.includes(\"create\")) {\n    router.post(\n      basePath,\n      ...createHandlers(middlewares, normalizedName, \"create\")\n    );\n  }\n\n  // 4. Parameter routes last\n  if (actions.includes(\"show\")) {\n    router.get(\n      basePath + \"/:id\",\n      ...createHandlers(middlewares, normalizedName, \"show\")\n    );\n  }\n  if (actions.includes(\"update\")) {\n    router.put(\n      basePath + \"/:id\",\n      ...createHandlers(middlewares, normalizedName, \"update\")\n    );\n    router.patch(\n      basePath + \"/:id\",\n      ...createHandlers(middlewares, normalizedName, \"update\")\n    );\n  }\n  if (actions.includes(\"destroy\")) {\n    router.delete(\n      basePath + \"/:id\",\n      ...createHandlers(middlewares, normalizedName, \"destroy\")\n    );\n  }\n};\n\n// Helper function to create handlers array\nconst createHandlers = (\n  middlewares: RequestHandler[],\n  resourcePath: string,\n  action: string\n): RequestHandler[] => {\n  const handlers = [...getScopeMiddlewares(), ...middlewares];\n  const fullActionPath = `${resourcePath}/${action}`;\n  handlers.push(loadAction(fullActionPath));\n  return handlers;\n};\n\n// Export scope as an alias for routeScope\nexport const scope = routeScope;\n\nexport {\n  getRouter,\n  getActionsPath,\n  setActionsPath,\n  resetRouter,\n  routeScope,\n  setRouterOptions,\n};\n"],
  "mappings": "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",
  "names": ["path", "actionsPath", "router", "path", "options", "path", "router"]
}
